"""Manage application-specific configuration and caches
"""

import BitTornado
import sys
import os
import time
from binascii import hexlify, unhexlify
from .inifile import ini_write, ini_read
from BitTornado.Meta.bencode import bencode, bdecode
from .parseargs import defaultargs

DIRNAME = '.' + BitTornado.product_name


class ConfigDir(object):
    """Class for managing configuration data and caches"""
    dir_torrentcache = dir_datacache = dir_piececache = ''

    def __init__(self, config_type=None):
        # Figure out a sensible application data location
        for envvar in ('APPDATA', 'HOME', 'HOMEPATH', 'USERPROFILE'):
            appdata = os.environ.get(envvar)
            if appdata:
                break
        else:
            appdata = os.path.expanduser('~')
            if not os.path.isdir(appdata):
                appdata = os.path.abspath(os.path.dirname(sys.argv[0]))

        # Config directory is ~/.BitTornado or equivalent
        dir_root = os.path.join(appdata, DIRNAME)

        # Create directory or fail loudly
        if not os.path.isdir(dir_root):
            os.mkdir(dir_root, 0o700)

        # Create subdirectories if missing, and reference with self.dir_*
        for attr in ('torrentcache', 'datacache', 'piececache'):
            path = os.path.join(dir_root, attr)
            if not os.path.isdir(path):
                os.mkdir(path)
            setattr(self, 'dir_' + attr, path)

        # Allow caller-specific config and state data
        ext = '' if config_type is None else ('.' + config_type)

        self.configfile = os.path.join(dir_root, 'config' + ext + '.ini')
        self.statefile = os.path.join(dir_root, 'state' + ext)

        self.torrentDataBuffer = {}
        self.config = {}

    ###### CONFIG HANDLING ######
    def setDefaults(self, defaults, ignore=()):
        """Set config to default arguments, with option to ignore arguments"""
        self.config = defaultargs(defaults)
        for key in ignore:
            self.config.pop(key, None)

    def loadConfig(self):
        """Read configuration file and update local config dictionary"""
        newconfig = ini_read(self.configfile).get('')

        if not newconfig:
            return self.config

        # Track which keys aren't seen in config file
        configkeys = set(self.config)

        for key, val in newconfig.items():
            if key in self.config:
                try:
                    if isinstance(self.config[key], str):
                        self.config[key] = val
                    elif isinstance(self.config[key], int):
                        self.config[key] = int(val)
                    elif isinstance(self.config[key], float):
                        self.config[key] = float(val)
                    configkeys.discard(key)
                except ValueError:
                    pass

        if configkeys:  # Unsaved keys or invalid types prompt re-saving
            self.saveConfig()
        return self.config

    def saveConfig(self, new_config=None):
        """Save config dictionary to config file"""
        if new_config:
            for key, val in new_config.items():
                if key in self.config:
                    self.config[key] = val
        return ini_write(self.configfile, self.config, 'Generated by {}/{}\n{}'
                         ''.format(BitTornado.product_name,
                                   BitTornado.version_short,
                                   time.strftime('%x %X')))

    ###### TORRENT DATA HANDLING ######
    def getTorrentData(self, torrent):
        """Read a torrent data file from cache"""
        if torrent in self.torrentDataBuffer:
            return self.torrentDataBuffer[torrent]
        fname = os.path.join(self.dir_datacache, hexlify(torrent).decode())
        if not os.path.exists(fname):
            return None
        try:
            with open(fname, 'rb') as f:
                data = bdecode(f.read())
        except (IOError, ValueError):
            data = None
        self.torrentDataBuffer[fname] = data
        return data

    def writeTorrentData(self, torrent, data):
        """Add a torrent data file to cache"""
        self.torrentDataBuffer[torrent] = data
        fname = os.path.join(self.dir_datacache, hexlify(torrent).decode())
        try:
            with open(fname, 'wb') as f:
                f.write(bencode(data))
            return True
        except (IOError, TypeError, KeyError):
            self.deleteTorrentData(torrent)
            return False

    def deleteTorrentData(self, torrent):
        """Remove a torrent data file from cache"""
        self.torrentDataBuffer.pop(torrent, None)
        try:
            os.remove(os.path.join(self.dir_datacache,
                                   hexlify(torrent).decode()))
        except OSError:
            pass

    def getPieceDir(self, torrent):
        """Get torrent-specific piece cache directory"""
        return os.path.join(self.dir_piececache, hexlify(torrent).decode())

    ###### EXPIRATION HANDLING ######
    def deleteOldCacheData(self, days, still_active=(), delete_torrents=False):
        """Remove cache data after a given number of days inactive"""
        if not days:
            return
        exptime = time.time() - (days * 24 * 3600)
        names = {}
        times = {}

        for torrent in os.listdir(self.dir_torrentcache):
            path = os.path.join(self.dir_torrentcache, torrent)
            torrent = unhexlify(os.path.basename(torrent).split('.')[0])
            if len(torrent) != 20:
                continue
            if delete_torrents:
                names.setdefault(torrent, []).append(path)
            try:
                mtime = os.path.getmtime(path)
            except OSError:
                mtime = time.time()
            times.setdefault(torrent, []).append(mtime)

        for fname in os.listdir(self.dir_datacache):
            path = os.path.join(self.dir_datacache, fname)
            fname = unhexlify(os.path.basename(fname))
            if len(fname) != 20:
                continue
            names.setdefault(fname, []).append(path)
            try:
                mtime = os.path.getmtime(path)
            except OSError:
                mtime = time.time()
            times.setdefault(fname, []).append(mtime)

        for piece in os.listdir(self.dir_piececache):
            piecepath = os.path.join(self.dir_piececache, piece)
            piece = unhexlify(os.path.basename(piece))
            if len(piece) != 20:
                continue

            for fname in os.listdir(piecepath):
                path = os.path.join(piecepath, fname)
                names.setdefault(piece, []).append(path)
                try:
                    mtime = os.path.getmtime(path)
                except OSError:
                    mtime = time.time()
                times.setdefault(piece, []).append(mtime)
            names.setdefault(piece, []).append(piecepath)

        for obj, mtime in times.items():
            if max(mtime) < exptime and obj not in still_active:
                for fname in names[obj]:
                    try:
                        os.remove(fname)
                    except OSError:
                        try:
                            os.removedirs(fname)
                        except OSError:
                            pass
